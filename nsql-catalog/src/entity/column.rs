use std::fmt;

use nsql_storage::eval::Expr;

use super::*;

#[derive(Debug, Clone, PartialEq, Eq, Hash, FromTuple, IntoTuple)]
pub struct Column {
    pub(crate) table: Oid<Table>,
    pub(crate) index: ColumnIndex,
    pub(crate) ty: LogicalType,
    pub(crate) name: Name,
    pub(crate) is_primary_key: bool,
    pub(crate) identity: ColumnIdentity,
    pub(crate) default_expr: Expr,
}

impl From<Column> for ColumnStorageInfo {
    #[inline]
    fn from(val: Column) -> Self {
        ColumnStorageInfo {
            name: val.name.clone(),
            logical_type: val.logical_type(),
            is_primary_key: val.is_primary_key(),
        }
    }
}

impl From<&Column> for ColumnStorageInfo {
    fn from(col: &Column) -> Self {
        ColumnStorageInfo::new(col.name.clone(), col.ty.clone(), col.is_primary_key)
    }
}

impl Column {
    pub fn new(
        table: Oid<Table>,
        name: Name,
        index: ColumnIndex,
        ty: LogicalType,
        is_primary_key: bool,
        identity: ColumnIdentity,
        default_expr: Expr,
    ) -> Self {
        Self { table, name, index, ty, is_primary_key, identity, default_expr }
    }

    #[inline]
    pub fn index(&self) -> ColumnIndex {
        self.index
    }

    #[inline]
    pub fn name(&self) -> Name {
        Name::clone(&self.name)
    }

    #[inline]
    pub fn logical_type(&self) -> LogicalType {
        self.ty.clone()
    }

    #[inline]
    pub fn is_primary_key(&self) -> bool {
        self.is_primary_key
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ColumnIndex {
    index: u8,
}

impl fmt::Display for ColumnIndex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.index)
    }
}

impl FromValue for ColumnIndex {
    #[inline]
    fn from_value(value: Value) -> Result<Self, CastError> {
        let index = value.cast::<u8>()?;
        Ok(Self { index })
    }
}

impl From<ColumnIndex> for Value {
    #[inline]
    fn from(val: ColumnIndex) -> Self {
        Value::Int64(val.index as i64)
    }
}

impl ColumnIndex {
    // FIXME ideally this would be private
    #[inline]
    pub fn new(index: u8) -> Self {
        Self { index }
    }

    #[inline]
    pub fn as_usize(self) -> usize {
        self.index as usize
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CreateColumnInfo {
    pub name: Name,
    /// The index of the column in the table.
    pub index: u8,
    pub ty: LogicalType,
    pub is_primary_key: bool,
    pub identity: ColumnIdentity,
    pub default_expr: Expr,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ColumnIdentity {
    /// Not an identity column.
    None,
    /// Generated by default.
    ByDefault,
    /// Generated always.
    Always,
}

impl FromValue for ColumnIdentity {
    #[inline]
    fn from_value(value: Value) -> Result<Self, CastError> {
        let index = value.cast::<u8>()?;
        match index {
            b'\0' => Ok(Self::None),
            b'd' => Ok(Self::ByDefault),
            b'a' => Ok(Self::Always),
            _ => panic!("invalid column identity value"),
        }
    }
}

impl From<ColumnIdentity> for Value {
    #[inline]
    fn from(val: ColumnIdentity) -> Self {
        match val {
            ColumnIdentity::None => Value::Byte(b'\0'),
            ColumnIdentity::ByDefault => Value::Byte(b'd'),
            ColumnIdentity::Always => Value::Byte(b'a'),
        }
    }
}

impl SystemEntity for Column {
    type Parent = Table;

    type Key = (Oid<Self::Parent>, ColumnIndex);

    type SearchKey = (Oid<Self::Parent>, Name);

    #[inline]
    fn key(&self) -> Self::Key {
        (self.table, self.index)
    }

    #[inline]
    fn search_key(&self) -> Self::SearchKey {
        (self.table, self.name())
    }

    #[inline]
    fn name<'env, S: StorageEngine>(
        &self,
        _catalog: Catalog<'env, S>,
        _tx: &dyn Transaction<'env, S>,
    ) -> Result<Name> {
        Ok(Name::clone(&self.name))
    }

    #[inline]
    fn desc() -> &'static str {
        "column"
    }

    #[inline]
    fn parent_oid<'env, S: StorageEngine>(
        &self,
        _catalog: Catalog<'env, S>,
        _tx: &dyn Transaction<'env, S>,
    ) -> Result<Option<Oid<Self::Parent>>> {
        Ok(Some(self.table))
    }

    fn bootstrap_column_info() -> Vec<Column> {
        let table = Self::table();
        vec![
            Column {
                table,
                index: ColumnIndex::new(0),
                ty: LogicalType::Oid,
                name: "table".into(),
                is_primary_key: true,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
            Column {
                table,
                index: ColumnIndex::new(1),
                ty: LogicalType::Int64,
                name: "index".into(),
                is_primary_key: true,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
            Column {
                table,
                index: ColumnIndex::new(2),
                ty: LogicalType::Type,
                name: "ty".into(),
                is_primary_key: false,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
            Column {
                table,
                index: ColumnIndex::new(3),
                ty: LogicalType::Text,
                name: "name".into(),
                is_primary_key: false,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
            Column {
                table,
                index: ColumnIndex::new(4),
                ty: LogicalType::Bool,
                name: "is_primary_key".into(),
                is_primary_key: false,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
            Column {
                table,
                index: ColumnIndex::new(5),
                ty: LogicalType::Byte,
                name: "identity".into(),
                is_primary_key: false,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
            Column {
                table,
                index: ColumnIndex::new(6),
                ty: LogicalType::Expr,
                name: "default_expr".into(),
                is_primary_key: false,
                identity: ColumnIdentity::None,
                default_expr: Expr::null(),
            },
        ]
    }

    #[inline]
    fn table() -> Oid<Table> {
        Table::ATTRIBUTE
    }
}
